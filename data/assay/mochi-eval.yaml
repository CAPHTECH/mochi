schemaVersion: "1.0.0"
version: "v2025-01-11"
name: "mochi-code-completion-eval"
description: "Mochi code completion quality evaluation - TypeScript, YAML, error handling"

defaultParams:
  k: 1
  timeoutMs: 120000

queries:
  # ============================================
  # Category: method-completion (4 cases)
  # ============================================

  - id: "ts-method-001"
    text: "DuckDB query - all method"
    payload:
      instruction: "Fill in the typescript code"
      input: |
        // File: src/db/client.ts
        const users = await db.
      context: |
        // Available methods on DuckDBClient:
        //   all<T>(sql: string, params?: any[]): Promise<T[]>
        //   run(sql: string, params?: any[]): Promise<void>
        //   prepare(sql: string): Statement
      expectedKeywords: ["all"]
      forbiddenKeywords: ["query", "execute", "fetch"]
    metadata:
      category: "method-completion"
      language: "typescript"
      difficulty: "easy"

  - id: "ts-method-002"
    text: "DuckDB query - run method"
    payload:
      instruction: "Fill in the typescript code"
      input: |
        // File: src/db/migration.ts
        // Delete all inactive users
        await db.
      context: |
        // Available methods on DuckDBClient:
        //   all<T>(sql: string, params?: any[]): Promise<T[]>
        //   run(sql: string, params?: any[]): Promise<void>
        //   prepare(sql: string): Statement
      expectedKeywords: ["run", "DELETE"]
      forbiddenKeywords: ["query", "execute"]
    metadata:
      category: "method-completion"
      language: "typescript"
      difficulty: "easy"

  - id: "ts-method-003"
    text: "Vector search - similarity method"
    payload:
      instruction: "Fill in the typescript code"
      input: |
        // File: src/search/vector.ts
        const similar = await vectorDb.
      context: |
        // Available methods on VectorDatabase:
        //   search(query: number[], topK: number): Promise<SearchResult[]>
        //   insert(id: string, vector: number[]): Promise<void>
        //   delete(id: string): Promise<boolean>
      expectedKeywords: ["search"]
      forbiddenKeywords: ["query", "find", "similarity"]
    metadata:
      category: "method-completion"
      language: "typescript"
      difficulty: "medium"

  - id: "ts-method-004"
    text: "Cache operations"
    payload:
      instruction: "Fill in the typescript code"
      input: |
        // File: src/cache/manager.ts
        // Check if key exists before fetching
        if (await cache.
      context: |
        // Available methods on CacheManager:
        //   get<T>(key: string): Promise<T | null>
        //   set<T>(key: string, value: T, ttl?: number): Promise<void>
        //   has(key: string): Promise<boolean>
        //   delete(key: string): Promise<boolean>
      expectedKeywords: ["has"]
      forbiddenKeywords: ["exists", "contains", "check"]
    metadata:
      category: "method-completion"
      language: "typescript"
      difficulty: "medium"

  # ============================================
  # Category: yaml-completion (3 cases)
  # ============================================

  - id: "yaml-001"
    text: "YAML stop-words list continuation"
    payload:
      instruction: "Complete the YAML configuration"
      input: |
        # File: config/stop-words.yml
        code_generic:
          - undefined
          - "true"
          - "false"
          -
      expectedKeywords: ["null"]
    metadata:
      category: "yaml-completion"
      language: "yaml"
      difficulty: "easy"

  - id: "yaml-002"
    text: "YAML scoring profile"
    payload:
      instruction: "Complete the YAML configuration"
      input: |
        # File: config/scoring-profiles.yml
        bugfix:
          graphInbound: 0.5
          graphOutbound:
      expectedKeywords: ["0."]
      expectedPattern: "\\d+\\.\\d+"
    metadata:
      category: "yaml-completion"
      language: "yaml"
      difficulty: "medium"

  - id: "yaml-003"
    text: "YAML query dataset entry"
    payload:
      instruction: "Complete the YAML configuration"
      input: |
        # File: datasets/queries.yaml
        queries:
          - id: "feature-001"
            text: "user authentication"
            metadata:
              category:
      expectedKeywords: ["feature", "auth"]
    metadata:
      category: "yaml-completion"
      language: "yaml"
      difficulty: "medium"

  # ============================================
  # Category: error-handling (3 cases)
  # ============================================

  - id: "ts-error-001"
    text: "Basic try-catch"
    payload:
      instruction: "Add error handling to this function"
      input: |
        async function fetchUser(id: string) {
          const response = await fetch(`/api/users/${id}`);
      expectedKeywords: ["try", "catch"]
      expectedPattern: "catch\\s*\\("
    metadata:
      category: "error-handling"
      language: "typescript"
      difficulty: "easy"

  - id: "ts-error-002"
    text: "Error with custom type"
    payload:
      instruction: "Add error handling with proper error type"
      input: |
        // File: src/api/client.ts
        async function makeRequest<T>(url: string): Promise<T> {
          const response = await fetch(url);
      context: |
        // Available error classes:
        //   class ApiError extends Error { statusCode: number; }
        //   class NetworkError extends Error { retryable: boolean; }
      expectedKeywords: ["try", "catch", "ApiError"]
      expectedPattern: "catch\\s*\\("
    metadata:
      category: "error-handling"
      language: "typescript"
      difficulty: "medium"

  - id: "ts-error-003"
    text: "Error with finally"
    payload:
      instruction: "Add error handling with cleanup"
      input: |
        // File: src/db/transaction.ts
        async function executeTransaction(queries: string[]) {
          const conn = await pool.getConnection();
      expectedKeywords: ["try", "catch", "finally", "release"]
      expectedPattern: "finally\\s*\\{"
    metadata:
      category: "error-handling"
      language: "typescript"
      difficulty: "hard"

  # ============================================
  # Category: llm-assist (3 cases)
  # LLM補助効果 - mochiコンテキストが幻覚を防ぐか検証
  # ============================================

  - id: "llm-assist-001"
    text: "LLM hallucination prevention - kiri search"
    payload:
      instruction: "Fill in the code. Use ONLY methods listed in the context."
      input: |
        // File: src/search/semantic.ts
        // Find similar code snippets for the query
        const results = await kiriClient.
      context: |
        // kiriClient: KiriMCPClient (from kiri MCP server)
        // Available methods:
        //   snippets_search(query: string, limit?: number): Promise<Snippet[]>
        //   context_bundle(file: string): Promise<Bundle>
        //   files_search(pattern: string): Promise<File[]>
      expectedKeywords: ["snippets_search"]
      forbiddenKeywords: ["search", "find", "query", "get", "fetch"]
    metadata:
      category: "llm-assist"
      scenario: "hallucination-prevention"
      difficulty: "medium"
      shouldCallTool: true
      expectedTool: "mochi_domain_query"

  - id: "llm-assist-002"
    text: "LLM hallucination prevention - embedding"
    payload:
      instruction: "Complete the code using only the provided API."
      input: |
        // File: src/embedding/service.ts
        // Generate embedding for the text
        const vector = await embedder.
      context: |
        // embedder: EmbeddingService
        // Available methods:
        //   encode(text: string): Promise<number[]>
        //   encodeBatch(texts: string[]): Promise<number[][]>
      expectedKeywords: ["encode"]
      forbiddenKeywords: ["embed", "embedding", "vectorize", "transform"]
    metadata:
      category: "llm-assist"
      scenario: "hallucination-prevention"
      difficulty: "medium"
      shouldCallTool: true
      expectedTool: "mochi_domain_query"

  - id: "llm-assist-003"
    text: "LLM guidance - correct return type"
    payload:
      instruction: "Complete the function signature based on the context."
      input: |
        // File: src/api/response.ts
        async function getUsers():
      context: |
        // Project convention: All API responses use Result type
        // type Result<T> = { ok: true; data: T } | { ok: false; error: Error }
        // Never return raw arrays or Promise<T[]>
      expectedKeywords: ["Result"]
      forbiddenKeywords: ["[]", "Array"]
    metadata:
      category: "llm-assist"
      scenario: "convention-guidance"
      difficulty: "medium"
      shouldCallTool: true
      expectedTool: "mochi_domain_query"

  # ============================================
  # Category: domain-pattern (2 cases)
  # ドメインパターン伝達 - kiri固有パターンを正しく伝えられるか
  # ============================================

  - id: "domain-pattern-001"
    text: "kiri error handling pattern"
    payload:
      instruction: "Add error handling following the project pattern."
      input: |
        // File: src/mcp/handler.ts
        async function handleToolCall(name: string, args: unknown) {
          const tool = tools.get(name);
      context: |
        // Project error handling pattern:
        // 1. Use custom error classes (ToolNotFoundError, ValidationError)
        // 2. Always include error code and context
        // 3. Use Result<T, E> for recoverable errors
        // Example:
        //   if (!tool) throw new ToolNotFoundError(name, { available: [...tools.keys()] });
      expectedKeywords: ["ToolNotFoundError", "throw"]
      forbiddenKeywords: ["Error(", "new Error"]
    metadata:
      category: "domain-pattern"
      pattern: "error-handling"
      difficulty: "hard"
      shouldCallTool: true
      expectedTool: "mochi_suggest_pattern"

  - id: "domain-pattern-002"
    text: "kiri logging pattern"
    payload:
      instruction: "Add appropriate logging following project conventions."
      input: |
        // File: src/indexer/worker.ts
        async function processFile(path: string) {
          // Log start of processing
      context: |
        // Project logging pattern:
        // 1. Use structured logging with logger.info/warn/error
        // 2. Always include context object: logger.info("message", { key: value })
        // 3. Use consistent event names: "file:process:start", "file:process:end"
      expectedKeywords: ["logger", "info", "file:process"]
      forbiddenKeywords: ["console.log", "console.info"]
    metadata:
      category: "domain-pattern"
      pattern: "logging"
      difficulty: "medium"
      shouldCallTool: true
      expectedTool: "mochi_suggest_pattern"

  # ============================================
  # Category: context-quality (2 cases)
  # コンテキスト品質 - LSPコンテキストが正確で有用か
  # ============================================

  - id: "context-quality-001"
    text: "LSP method signature accuracy"
    payload:
      instruction: "Call the method with correct parameters based on the signature."
      input: |
        // File: src/search/indexer.ts
        await index.
      context: |
        // index: SearchIndex
        // Methods:
        //   add(doc: Document, options?: IndexOptions): Promise<void>
        //   remove(id: string): Promise<boolean>
        //   update(id: string, partial: Partial<Document>): Promise<void>
      expectedKeywords: ["add", "Document"]
      expectedPattern: "add\\s*\\("
    metadata:
      category: "context-quality"
      aspect: "method-signature"
      difficulty: "easy"
      shouldCallTool: true
      expectedTool: "mochi_domain_query"

  - id: "context-quality-002"
    text: "Type inference from context"
    payload:
      instruction: "Complete the type annotation based on the context."
      input: |
        // File: src/config/loader.ts
        function loadConfig(path: string):
      context: |
        // Config loading in this project:
        // - Returns ConfigResult which is Result<Config, ConfigError>
        // - Config has: { database: DbConfig, cache: CacheConfig, logging: LogConfig }
        // - ConfigError has: code, message, path
      expectedKeywords: ["ConfigResult", "Result"]
    metadata:
      category: "context-quality"
      aspect: "type-inference"
      difficulty: "medium"
      shouldCallTool: true
      expectedTool: "mochi_domain_query"

  # ============================================
  # Category: e2e-workflow (2 cases)
  # E2Eワークフロー - Claude Code + mochi統合のユースケース
  # ============================================

  - id: "e2e-001"
    text: "Claude Code integration - code review assist"
    payload:
      instruction: "Suggest improvements based on project conventions."
      input: |
        // Review target: src/api/users.ts
        export async function getUser(id: string) {
          const user = await db.query("SELECT * FROM users WHERE id = ?", [id]);
          return user;
        }
      context: |
        // Project conventions:
        // 1. Use typed query methods: db.all<T>(), db.get<T>()
        // 2. Return Result<T> not raw values
        // 3. Add input validation with zod
        // 4. Use prepared statements via db.prepare()
      expectedKeywords: ["all", "Result", "zod"]
      forbiddenKeywords: ["query"]
    metadata:
      category: "e2e-workflow"
      scenario: "code-review"
      difficulty: "hard"
      shouldCallTool: true
      expectedTool: "mochi_domain_query"

  - id: "e2e-002"
    text: "Claude Code integration - implementation from spec"
    payload:
      instruction: "Implement the function according to the specification."
      input: |
        // Spec: Create a function that searches for files matching a pattern
        // Should use kiri MCP server methods
        async function searchFiles(pattern: string):
      context: |
        // kiriClient: KiriMCPClient
        // Available:
        //   files_search(pattern: string): Promise<FileMatch[]>
        //   files_read(path: string): Promise<string>
        // FileMatch: { path: string, score: number }
      expectedKeywords: ["files_search", "FileMatch"]
      forbiddenKeywords: ["glob", "fs.", "readdir"]
    metadata:
      category: "e2e-workflow"
      scenario: "implementation"
      difficulty: "hard"
      shouldCallTool: true
      expectedTool: "mochi_domain_query"

# Expected results for precision/recall calculation
expected:
  - id: "ts-method-001"
    reference:
      keywords: ["all<", "SELECT"]

  - id: "ts-method-002"
    reference:
      keywords: ["run(", "DELETE"]

  - id: "ts-method-003"
    reference:
      keywords: ["search("]

  - id: "ts-method-004"
    reference:
      keywords: ["has("]

  - id: "yaml-001"
    reference:
      keywords: ["null", "void"]

  - id: "yaml-002"
    reference:
      patterns: ["\\d+\\.\\d+"]

  - id: "yaml-003"
    reference:
      keywords: ["feature"]

  - id: "ts-error-001"
    reference:
      patterns: ["try\\s*\\{", "catch\\s*\\("]

  - id: "ts-error-002"
    reference:
      keywords: ["ApiError", "try", "catch"]

  - id: "ts-error-003"
    reference:
      keywords: ["try", "catch", "finally"]

  # llm-assist category
  - id: "llm-assist-001"
    reference:
      keywords: ["snippets_search"]

  - id: "llm-assist-002"
    reference:
      keywords: ["encode"]

  - id: "llm-assist-003"
    reference:
      keywords: ["Result"]

  # domain-pattern category
  - id: "domain-pattern-001"
    reference:
      keywords: ["ToolNotFoundError"]

  - id: "domain-pattern-002"
    reference:
      keywords: ["logger", "file:process"]

  # context-quality category
  - id: "context-quality-001"
    reference:
      keywords: ["add"]
      patterns: ["add\\s*\\("]

  - id: "context-quality-002"
    reference:
      keywords: ["ConfigResult"]

  # e2e-workflow category
  - id: "e2e-001"
    reference:
      keywords: ["all", "Result"]

  - id: "e2e-002"
    reference:
      keywords: ["files_search", "FileMatch"]
